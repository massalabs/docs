"use strict";(self.webpackChunkdocu_dev=self.webpackChunkdocu_dev||[]).push([[982],{5586:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=t(4848),i=t(8453);const a={id:"operation-lifecycle",sidebar_label:"Operation lifecycle"},l="Operation lifecycle",s={id:"learn/architecture/operation-lifecycle",title:"Operation lifecycle",description:"After learning about the Basic concepts and Massa's node architecture, we have all the elements and vocabulary",source:"@site/docs/learn/architecture/operation-lifecycle.mdx",sourceDirName:"learn/architecture",slug:"/learn/architecture/operation-lifecycle",permalink:"/docs/learn/architecture/operation-lifecycle",draft:!1,unlisted:!1,editUrl:"https://github.com/massalabs/docs/tree/main/docs/learn/architecture/operation-lifecycle.mdx",tags:[],version:"current",lastUpdatedBy:"Damir Vodenicarevic",lastUpdatedAt:1723551924e3,frontMatter:{id:"operation-lifecycle",sidebar_label:"Operation lifecycle"},sidebar:"learnSidebar",previous:{title:"Node architecture",permalink:"/docs/learn/architecture/node-architecture"},next:{title:"Consensus quality initiatives",permalink:"/docs/learn/architecture/consensus-quality"}},r={},c=[{value:"Read-only operations",id:"read-only-operations",level:2}];function d(e){const n={h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"operation-lifecycle",children:"Operation lifecycle"})}),"\n",(0,o.jsx)(n.p,{children:"After learning about the Basic concepts and Massa's node architecture, we have all the elements and vocabulary\nin place to explore the lifecycle of an operation within the network; from creation to permanent execution in\na finalized block."}),"\n",(0,o.jsx)(n.p,{children:"Operations originate externally from a client that is forging the operation, for example: a transaction or a\nsmart contract code execution. The client will have to know the IP address of a Massa Node (this can be either\nbecause it is a node itself and will simply use localhost, or via some maintained list of known nodes and/or\nsome browser plugin), and will then send the operation to the API."}),"\n",(0,o.jsx)(n.p,{children:"When an operation is made available in a given node, it will be broadcasted to all other nodes via the Protocol/Network\nModule and to factories via the API Module, so that it will eventually end up in all the Pool Modules of the network."}),"\n",(0,o.jsx)(n.p,{children:"Let\u2019s assume we just got a code execution operation from an external client. Let\u2019s suppose the client knows a\nparticular node, which is running its block factory on the same machine, and sends the operation to this node.\nThese are the different steps of the operation processing that will occur, as illustrated in the schema below:"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:t(3799).A+""})}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The operation enters the node via the API Module (the operation path is marked in blue)"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The API Module forwards the operation to the Pool Module and broadcasts it to other nodes via the Protocol/Network\nModule. Other nodes hearing about it will also broadcast it (gossip protocol), and feed it to their Pool Module."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"At that stage, the operation sits in the Pool Modules of most nodes. Note that a given operation does not have a specific nounce, and as a result can be included in any order relative to other operations."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The Selector Module elects a particular node to handle the block production of the next current slot"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The elected node Block Factory finds out about its election by querying a Selector Module"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"It starts building a block by picking up pending operations in the Pool Module. The original operation is\neventually picked and integrated into the block. It's worth to mention that only operations created by an address within the same thread as the block can be included. This is known as a 'transaction sharding' technique and it's used to prevent double spending problem. We will now follow the block around (the block path is marked in green)"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The newly produced block is sent to the Graph/Consensus Module"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The new block is processed by the Graph/Consensus Module to be included into the pending blocks DAG and\npotentially integrated into a new blockclique"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The Graph/Consensus Module sends the new block to other nodes via the Protocol/Network Module, to ensure\nsynchronization of the information in the network. The new block reaching other nodes is similarly going to be integrated into their Graph/Consensus Module"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"In general, the blockclique will be extended with the new block and so will reach the Execution Module\nfrom the Graph/Consensus Module via the notification of a new blockclique. Eventually, it will also be notified\nas a final block if it gets finalized."}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The Execution Module will run the blocks that are part of the updated blockclique, so the original block\nwill eventually be executed. Within the block is the original operation that was originally sent and that will\nthen be applied to the ledger for potential modifications. At this stage, the modifications are not permanent and\nsimply stored in a diff compared to the finalized ledger"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Eventually, the block will be marked as final and the ledger modification, including the operation changes,\nwill become final in the finalized ledger."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"read-only-operations",children:"Read-only operations"}),"\n",(0,o.jsx)(n.p,{children:"Besides normal operations described previously, massa nodes can also execute read-only requests, aiming to simulate as closely as possible what would\nhappen if the user sent a real operation. These can be used for testing, or in order to get gas estimations (as the gas consumed by a read-only execution is\nreturned with the response)."}),"\n",(0,o.jsx)(n.p,{children:"The Execution Module will handle read-only request, and revert back any changes made to the state during the execution of such requests."}),"\n",(0,o.jsx)(n.p,{children:"The read-only execution happens at the slot just after the latest executed non-final slot at the moment of execution.\nThe same way you can't ensure at which height a normal operation is executed, different nodes might have processed different non-final blocks at a given time and execute the same read-only request under different contexts depending on that."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},3799:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/operation_lifecycle-201746987c637edaf2d8a3cf760c993a.svg"},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var o=t(6540);const i={},a=o.createContext(i);function l(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);