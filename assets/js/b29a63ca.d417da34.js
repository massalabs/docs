"use strict";(self.webpackChunkdocu_dev=self.webpackChunkdocu_dev||[]).push([[4209],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>g});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),c=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(o.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(a),d=r,g=m["".concat(o,".").concat(d)]||m[d]||u[d]||i;return a?n.createElement(g,s(s({ref:t},p),{},{components:a})):n.createElement(g,s({ref:t},p))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=d;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[m]="string"==typeof e?e:r,s[1]=l;for(var c=2;c<i;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},9834:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const i={},s="Calling a smart contract",l={unversionedId:"build/smart-contract/basic-concepts/functions-parameters",id:"build/smart-contract/basic-concepts/functions-parameters",title:"Calling a smart contract",description:"Functions that are part of a smart contract's public interface\u2014meaning they are exported from the contract entry point file\u2014can be invoked by end users or other smart contracts. These functions can accept parameters and return data.",source:"@site/docs/build/smart-contract/basic-concepts/functions-parameters.mdx",sourceDirName:"build/smart-contract/basic-concepts",slug:"/build/smart-contract/basic-concepts/functions-parameters",permalink:"/docs/build/smart-contract/basic-concepts/functions-parameters",draft:!1,editUrl:"https://github.com/massalabs/docs/tree/main/docs/build/smart-contract/basic-concepts/functions-parameters.mdx",tags:[],version:"current",lastUpdatedBy:"BenRey",lastUpdatedAt:1736169714,formattedLastUpdatedAt:"Jan 6, 2025",frontMatter:{},sidebar:"buildSidebar",previous:{title:"Smart Contract Data Types",permalink:"/docs/build/smart-contract/basic-concepts/data-types"},next:{title:"Constructor function",permalink:"/docs/build/smart-contract/basic-concepts/constructor"}},o={},c=[{value:"Example of a public callable function",id:"example-of-a-public-callable-function",level:3},{value:"Using Args for Serialization and Deserialization",id:"using-args-for-serialization-and-deserialization",level:2},{value:"Available Args Implementations",id:"available-args-implementations",level:3},{value:"Benefits of using Args",id:"benefits-of-using-args",level:3},{value:"Native serializable types",id:"native-serializable-types",level:2},{value:"Supported Serializable Types",id:"supported-serializable-types",level:3},{value:"Examples of a string serialization / deserialization with args",id:"examples-of-a-string-serialization--deserialization-with-args",level:3},{value:"Explanation of the code",id:"explanation-of-the-code",level:4},{value:"Calling the contract from TypeScript",id:"calling-the-contract-from-typescript",level:4},{value:"Example of multi argument deserialization with args",id:"example-of-multi-argument-deserialization-with-args",level:3}],p={toc:c},m="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(m,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"calling-a-smart-contract"},"Calling a smart contract"),(0,r.kt)("p",null,"Functions that are part of a smart contract's public interface\u2014meaning they are exported from the contract entry point file\u2014can be invoked by end users or other smart contracts. These functions can accept parameters and return data."),(0,r.kt)("p",null,"Currently, function arguments and return values only support raw bytes, represented as ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticArray<u8>"),". This approach allows for flexible data handling, as any data type can be serialized to raw bytes for transmission and processing."),(0,r.kt)("h3",{id:"example-of-a-public-callable-function"},"Example of a public callable function"),(0,r.kt)("p",null,"Here is an example of a public callable function named hello, which takes and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticArray<u8>")," :"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// main.ts \nexport function hello(argsData: StaticArray<u8>): StaticArray<u8> {\n    // Function logic here\n}\n")),(0,r.kt)("p",null,"Since raw bytes are used as both input and output, you can work with various data types by serializing them to ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticArray<u8>")," for input and deserializing them back into the appropriate type within the function. Similarly, any return data should be serialized to ",(0,r.kt)("inlineCode",{parentName:"p"},"StaticArray<u8>")," before being sent back."),(0,r.kt)("h1",{id:"serialization-and-deserialization"},"Serialization and Deserialization"),(0,r.kt)("p",null,"To use complex data types in your public callable functions, you must first serialize them into raw bytes before passing them as arguments. On the receiving end, the function will need to deserialize the bytes back into the original data type. This allows for versatile function inputs and outputs, even though the system natively supports only raw byte arrays."),(0,r.kt)("h2",{id:"using-args-for-serialization-and-deserialization"},"Using Args for Serialization and Deserialization"),(0,r.kt)("p",null,"Massa provides specialized tools for handling the serialization and deserialization of data in both AssemblyScript and TypeScript, making it easier to manage data exchanges between smart contracts and other parts of the Massa ecosystem. These tools simplify the process of converting data into raw bytes for smart contract calls and results, and they ensure consistency across different parts of your project."),(0,r.kt)("h3",{id:"available-args-implementations"},"Available Args Implementations"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"AssemblyScript"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The Args implementation for AssemblyScript is available in the ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/massalabs/as/tree/main/packages/as-types"},"@massalabs/as-types")," package."),(0,r.kt)("li",{parentName:"ul"},"This package provides functions for encoding and decoding various data types (like integers, strings, and arrays) to and from raw bytes within smart contracts."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"TypeScript"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"For TypeScript, the Args implementation can be found in the ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/massalabs/massa-web3"},"@massalabs/massa-web3")," package."),(0,r.kt)("li",{parentName:"ul"},"This library is particularly useful for interfacing with Massa smart contracts from TypeScript-based applications, enabling seamless serialization and deserialization when calling smart contracts or handling call results."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Go"),":"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Certain aspects of serialization logic are also available in the Go programming language within the ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/massalabs/station"},"MassaStation")," codebase.\nThis can be beneficial for developers looking to integrate with Massa from Go-based applications or understand how the serialization is implemented at a lower level.")))),(0,r.kt)("h3",{id:"benefits-of-using-args"},"Benefits of using Args"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Consistent Serialization"),": By using Args, developers ensure that data serialization is consistent between the client and smart contract. This reduces the risk of data mismatches or errors during contract calls."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Simplified Data Handling"),": Args provides easy-to-use methods for encoding and decoding data, making it straightforward to work with complex data types like nested arrays or objects."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Cross-Language Compatibility"),": Since Args is implemented in multiple languages, it facilitates interoperability between smart contracts written in AssemblyScript and client applications in TypeScript or Go, broadening the range of possible integrations.")),(0,r.kt)("h2",{id:"native-serializable-types"},"Native serializable types"),(0,r.kt)("p",null,"Massa provides built-in support for serializing and deserializing AssemblyScript native types, big integers, and arrays of these types. The Args utility serves as a versatile tool for handling function parameters that involve multiple arguments, as well as for managing complex data structures in function returns."),(0,r.kt)("h3",{id:"supported-serializable-types"},"Supported Serializable Types"),(0,r.kt)("p",null,"The following types can be directly serialized and deserialized in Massa smart contracts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Native AssemblyScript Types"),": These includes basic types like integers (",(0,r.kt)("inlineCode",{parentName:"li"},"i32"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"u64"),", etc.), ",(0,r.kt)("inlineCode",{parentName:"li"},"bool"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"string"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Big Integers"),": Using the as-bignum library, Massa smart contracts can handle large integers beyond standard 64-bit limits such ",(0,r.kt)("inlineCode",{parentName:"li"},"u256"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Arrays"),": Arrays of native types, such as ",(0,r.kt)("inlineCode",{parentName:"li"},"Array<i32>")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"Array<string>"),", can also be serialized, allowing for the handling of collections of data in contract calls."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Generic serializable")," and array of serializable object: Serializable is a generic class that wrap the serialization logic and allow to define a custom serialization/deserialization of complex data.")),(0,r.kt)("h3",{id:"examples-of-a-string-serialization--deserialization-with-args"},"Examples of a string serialization / deserialization with args"),(0,r.kt)("p",null,"In this example, we use the hello function to demonstrate how to handle string arguments with Args. The hello function takes a user's name as a serialized string, deserializes it, and returns a personalized greeting message. This example assumes that the smart contract has already been deployed on the Massa blockchain."),(0,r.kt)("p",null,"Contract code (assemblyscript)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// main.ts (assemblyscript)\nimport { Args, stringToBytes } from '@massalabs/as-types';\n\nexport function hello(argsData: StaticArray<u8>): StaticArray<u8> {\n    const name = new Args(argsData).nextString().expect('Name argument is missing or invalid');\n    return strToBytes(`Hello ${name}!`)\n}\n")),(0,r.kt)("h4",{id:"explanation-of-the-code"},"Explanation of the code"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Import Statements:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"We import Args from ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/massalabs/as/tree/main/packages/as-types"},"@massalabs/as-types")," to handle the deserialization of function arguments."),(0,r.kt)("li",{parentName:"ul"},"stringToBytes is also imported, which converts the resulting greeting string into a byte array, as required for the function's return type."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Function Argument Deserialization:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"ArgsData is the raw byte input representing the serialized function arguments."),(0,r.kt)("li",{parentName:"ul"},"Args(ArgsData) initializes the Args object with the serialized data."),(0,r.kt)("li",{parentName:"ul"},"nextString() is called on the Args object to extract the next serialized string from the arguments. It's paired with expect(), which throws an error if the argument is missing or invalid."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Return Value Serialization:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The greeting message is created by interpolating the user-provided name into the string."),(0,r.kt)("li",{parentName:"ul"},"stringToBytes() converts the string message into a ",(0,r.kt)("inlineCode",{parentName:"li"},"StaticArray<u8>")," so that it can be returned in the expected format.")))),(0,r.kt)("h4",{id:"calling-the-contract-from-typescript"},"Calling the contract from TypeScript"),(0,r.kt)("p",null,"To call this hello function from a TypeScript application, you can use the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/massalabs/massa-web3"},"@massalabs/massa-web3")," library to serialize the argument and handle the response. Here's a quick example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// hello.ts (typescript)\nimport {\n  Account,\n  Args,\n  bytesToStr,\n  SmartContract,\n  JsonRpcProvider\n} from \'@massalabs/massa-web3\';\nconst account = await Account.fromEnv();\nconst provider = JsonRpcProvider.buildnet(account);\n\nconst helloContract = new SmartContract(provider, "<deployed_contract_address>");\n\nconst name = "Satoshi"\nconst args = new Args().addString(name)\nconst result = await helloContract.call(\'hello\',args);\n\n// deserialize message\nconst message = bytesToStr(result.value);\nconsole.log(message)\n// should log "Hello Satoshi!"\n')),(0,r.kt)("p",null,"In this example, we:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Serialize the Argument:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},'We create a new Args object and add a string argument ("Satoshi") to it, then serialize it for use in the contract call.'))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Deserialize the Response:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"After receiving the response, we use Args again to deserialize the returned bytes into a string, which gives us the greeting message.")))),(0,r.kt)("p",null,"By following this approach, you can easily handle string inputs and outputs in Massa smart contracts using the Args utility for serialization and deserialization."),(0,r.kt)("h3",{id:"example-of-multi-argument-deserialization-with-args"},"Example of multi argument deserialization with args"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// main.ts (assemblyscript)\nimport { Args, stringToBytes } from '@massalabs/as-types';\n\nexport function hello(argsData: StaticArray<u8>): StaticArray<u8> {\n    const args = new Args(argsData);\n    const name = args.nextString().expect('Name argument is missing or invalid');\n    const age = args.nextU8().expect('Age argument is missing or invalid');\n    return strToBytes(`Hello ${name}! ich bin ${age.toString()} jahre`)\n}\n")),(0,r.kt)("p",null,"Calling code (typescript)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// hello.ts (typescript)\nimport {\n  Args,\n  bytesToStr,\n  SmartContract,\n} from \'@massalabs/massa-web3\';\n{...}\nconst helloContract = new SmartContract(provider, "<deployed_contract_address>");\nconst name = "Satoshi";\nconst age = 8n;\nconst args = new Args().addString(name).addU8(age)\nconst result = await helloContract.call(\'hello\',args);\n\n// deserialize message\nconst message = bytesToStr(result.value);\nconsole.log(message)\n// should log "Hello Satoshi! ich bin 8 jahre"\n')),(0,r.kt)("p",null,"In the example below, args is used to serialize 2 arguments, a string name and a uint8 age.\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"nextString")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"nextU8")," should be done in the same order than done at serialization step"))}u.isMDXComponent=!0}}]);