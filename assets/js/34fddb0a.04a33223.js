"use strict";(self.webpackChunkdocu_dev=self.webpackChunkdocu_dev||[]).push([[9535],{2323:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var n=o(4848),s=o(8453);const a={id:"gas",sidebar_label:"Gas"},i="Gas",r={id:"learn/gas",title:"Gas",description:"Introduction",source:"@site/docs/learn/gas.mdx",sourceDirName:"learn",slug:"/learn/gas",permalink:"/docs/learn/gas",draft:!1,unlisted:!1,editUrl:"https://github.com/massalabs/docs/tree/main/docs/learn/gas.mdx",tags:[],version:"current",lastUpdatedBy:"Damir Vodenicarevic",lastUpdatedAt:1723580599e3,frontMatter:{id:"gas",sidebar_label:"Gas"},sidebar:"learnSidebar",previous:{title:"Storage costs",permalink:"/docs/learn/storage-costs"},next:{title:"Detailed operation format and execution sequence",permalink:"/docs/learn/operation-format-execution"}},c={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Gas in operations",id:"gas-in-operations",level:2},{value:"Gas in autonomous smart contracts",id:"gas-in-autonomous-smart-contracts",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"gas",children:"Gas"})}),"\n",(0,n.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,n.jsx)(t.p,{children:"In Massa, there are 2 slots per second. At each slot, an ensemble of autonomous smart contracts, as well as a block, are executed.\nIf a smart contract being called executed contains an infinite loop, it might hang the whole network.\nTo prevent this, it is required to cap the computation time of each slot below 500 milliseconds to allow the network to follow the slot schedule."}),"\n",(0,n.jsxs)(t.p,{children:["To do this we define a deterministic unit of computation time calibrated on a reference instance of the recommended hardware.\nWe call this unit ",(0,n.jsx)(t.code,{children:"gas"}),".\nEach smart contract instruction consumes a defined amount of ",(0,n.jsx)(t.code,{children:"gas"})," when executed."]}),"\n",(0,n.jsx)(t.p,{children:"Protocol-defined gas limits ensuring a total slot execution time remains below 300 milliseconds\non the reference hardware are set as follows:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["the execution of autonomous smart contracts at each slot: ",(0,n.jsx)(t.code,{children:"MAX_ASYNC_GAS = 1_000_000_000"})]}),"\n",(0,n.jsxs)(t.li,{children:["the execution of all the operations of a block: ",(0,n.jsx)(t.code,{children:"MAX_BLOCK_GAS = 4_294_967_295"})]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"gas-in-operations",children:"Gas in operations"}),"\n",(0,n.jsxs)(t.p,{children:["Block producers aim at maximizing their revenue by executing the operations that give them the highest total ",(0,n.jsx)(t.code,{children:"fee"})," in their blocks,\nwhile respecting the protocol-defined block size and gas limits to avoid their blocks from being rejected.\nHaving many pending operations compete for a limited amount of block space and gas creates a market for those resources.\nThis means that if the ",(0,n.jsx)(t.code,{children:"fee"})," of an operation is not set high enough to make it competitive given the space and gas it consumes,\nit less likely to be included by block producers.\nThey would prefer allocating those resources to other operations that are more profitable to them."]}),"\n",(0,n.jsxs)(t.p,{children:["Given the high throughput of the network and the low hardware requirements for block producers,\nit is not computationally feasible for block producers to simulate the execution of some types of operations\nin order to estimate the amount of gas their execution would require.\nOperations such as ",(0,n.jsx)(t.code,{children:"CallSC"})," or ",(0,n.jsx)(t.code,{children:"ExecuteSC"})," therefore contain a declarative ",(0,n.jsx)(t.code,{children:"max_gas"})," field\nthat caps the amount of ",(0,n.jsx)(t.code,{children:"gas"})," that can be consumed by the execution of the operation.\nThe sum of the ",(0,n.jsx)(t.code,{children:"max_gas"})," of all the operations of a block must not exceed ",(0,n.jsx)(t.code,{children:"MAX_BLOCK_GAS"}),".\nBeyond that, any excess operations in the block are not executed and do not profit to the block producer.\nIt is the responsibility of the operation sender to set a ",(0,n.jsx)(t.code,{children:"max_gas"})," value that is high enough.\nIf the execution of the operation exceeds its declared ",(0,n.jsx)(t.code,{children:"max_gas"}),",\nthe ",(0,n.jsx)(t.code,{children:"fee"})," is still paid but any other effects of the execution are reverted."]}),"\n",(0,n.jsx)(t.p,{children:"The gas usage of an operation can be estimated by its sender by using the read-only mode.\nThe used gas is returned by the read-only calls/executions."}),"\n",(0,n.jsx)(t.h2,{id:"gas-in-autonomous-smart-contracts",children:"Gas in autonomous smart contracts"}),"\n",(0,n.jsxs)(t.p,{children:["Autonomous smart contract also compete for a finite ",(0,n.jsx)(t.code,{children:"MAX_ASYNC_GAS"})," per slot.\nWhen emitting an autonomous smart contract message, the sender speficies a ",(0,n.jsx)(t.code,{children:"fee"})," and a ",(0,n.jsx)(t.code,{children:"max_gas"})," in the arguments.\nAutonomous smart contracts do not involve block producers, so the ",(0,n.jsx)(t.code,{children:"fee"})," is simply burned at emission."]}),"\n",(0,n.jsxs)(t.p,{children:["To replicate the priorization behavior of block producers in a deterministic way,\nthe autonomous smart contract pool sorts the autonomous smart contract messages\nby their profitability defined by the ",(0,n.jsx)(t.code,{children:"fee/max_gas"})," ratio."]}),"\n",(0,n.jsxs)(t.p,{children:["The pool is of finite size ",(0,n.jsx)(t.code,{children:"MAX_ASYNC_POOL_LENGTH = 1_000"}),".\nExpired messages are automatically dropped from that pool.\nDespite this, if the pool still grows beyond its length limit,\nthe least profitable messages are dropped to fit the limit.\nWhen a message is dropped, its ",(0,n.jsx)(t.code,{children:"coins"})," are reimbursed to the sender but not its ",(0,n.jsx)(t.code,{children:"fee"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["At each slot ",(0,n.jsx)(t.code,{children:"S"}),", the autonomous smart contract messages that can be executed at ",(0,n.jsx)(t.code,{children:"S"}),"\nare picked from the most profitable to the least profitable and executed in that order\nuntil their cumulated ",(0,n.jsx)(t.code,{children:"max_gas"})," reaches ",(0,n.jsx)(t.code,{children:"MAX_ASYNC_GAS"}),".\nAutonomous smart contract messages are removed from the pool once they are executed."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>i,x:()=>r});var n=o(6540);const s={},a=n.createContext(s);function i(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);